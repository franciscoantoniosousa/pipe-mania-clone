{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://pipe-master-clone/./src/helper.js","webpack://pipe-master-clone/./src/resources.js","webpack://pipe-master-clone/./src/cell.js","webpack://pipe-master-clone/./src/eDirection.js","webpack://pipe-master-clone/./src/player.js","webpack://pipe-master-clone/./src/game-manager.js","webpack://pipe-master-clone/./src/index.js"],"sourcesContent":["export function randomIntFromInterval(min, max) {\r\n  // min and max included\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}","export const images = [\r\n  '', // 0\r\n  './images/base-pipes/4-connector.png', // 1\r\n  './images/base-pipes/bottom-left-curve.png', // 2\r\n  './images/base-pipes/bottom-right-curve.png', // 3\r\n  './images/base-pipes/top-left-curve.png', // 4\r\n  './images/base-pipes/top-right-curve.png', // 5\r\n  './images/base-pipes/horizontal.png', // 6\r\n  './images/base-pipes/vertical.png', // 7\r\n  './images/base-pipes/blocked-pipe.png', // 8\r\n  './images/base-pipes/start-to-right.png', // 9\r\n  './images/base-pipes/start-to-left.png', // 10\r\n  './images/base-pipes/start-to-bottom.png', // 11\r\n  './images/base-pipes/start-to-top.png', // 12\r\n  './images/background.png', // 13\r\n  './images/filled-pipes/4-connector-filled.png', // 14\r\n  './images/filled-pipes/4-connector-horizontal-half.png', // 15\r\n  './images/filled-pipes/4-connector-vertical-half.png', // 16\r\n  './images/filled-pipes/bottom-left-curve-filled.png', // 17\r\n  './images/filled-pipes/bottom-right-curve-filled.png', // 18\r\n  './images/filled-pipes/top-left-curve-filled.png', // 19\r\n  './images/filled-pipes/top-right-curve-filled.png', // 20\r\n  './images/filled-pipes/horizontal-filled.png', // 21\r\n  './images/filled-pipes/vertical-filled.png', // 22\r\n  './images/filled-pipes/start-to-right-filled.png', // 23\r\n  './images/filled-pipes/start-to-left-filled.png', // 24\r\n  './images/filled-pipes/start-to-bottom-filled.png', // 25\r\n  './images/filled-pipes/start-to-top-filled.png', // 26\r\n\r\n];","import {images} from './resources';\r\nimport {Direction} from './eDirection';\r\n\r\nconst canvas = document.querySelector('canvas');\r\nconst context = canvas.getContext('2d');\r\nexport class Cell {\r\n  static cellWidth = 40;\r\n  static cellHeight = 40;\r\n\r\n  constructor({gameManager,position, src, type}) {\r\n    this.position = position;\r\n    this.width = 38;\r\n    this.height = 38;\r\n    this.gameManager = gameManager;\r\n\r\n    const pipeImage = new Image();\r\n    pipeImage.src = src;\r\n    pipeImage.onload = () => {\r\n      this.image = pipeImage;\r\n    };\r\n\r\n    const pipeWithWaterImage = new Image();\r\n    pipeWithWaterImage.src = images[this.getPipeWithWaterImage(type)];\r\n    pipeWithWaterImage.onload = () => {\r\n      this.imageFilled = pipeWithWaterImage;\r\n    };\r\n\r\n    \r\n    this.withWater = false;\r\n    this.type = type;\r\n    this.alreadyFilled = false;\r\n  }\r\n\r\n  getPipeWithWaterImage(type) {\r\n    console.log('trying to get filled water pipe');\r\n    switch (type) {\r\n      case 1:\r\n        if(this.alreadyFilled === false){\r\n          this.alreadyFilled = true;\r\n          if (this.gameManager.currentPipe.direction === Direction.Up || this.gameManager.currentPipe.direction === Direction.Down) {\r\n            return 16;\r\n          } else {\r\n            return 15;\r\n          }\r\n        }\r\n        return 14;\r\n      case 2:\r\n        return 17;\r\n      case 3:\r\n        return 18;\r\n      case 4:\r\n        return 19;\r\n      case 5:\r\n        return 20;\r\n      case 6:\r\n        return 21;\r\n      case 7:\r\n        return 22;\r\n      case 9:\r\n        return 23;\r\n      case 10:\r\n        return 24;\r\n      case 11:\r\n        return 25;\r\n      case 12:\r\n        return 26;\r\n    }\r\n  }\r\n\r\n  draw() {\r\n    const imageToDraw = this.withWater ? this.imageFilled : this.image;\r\n    if (imageToDraw) {\r\n      context.drawImage(\r\n          imageToDraw,\r\n          this.position.x,\r\n          this.position.y,\r\n          this.width,\r\n          this.height\r\n      );\r\n    } else {\r\n      context.fillStyle = 'rgb(255, 201, 14)';\r\n      context.fillRect(\r\n          this.position.x,\r\n          this.position.y,\r\n          this.width,\r\n          this.height\r\n      );\r\n    }\r\n  }\r\n  resize(newWidth, newHeight) {\r\n    // Tried to figure out how to dynamically change the graphic size when window is resized but was not successful    \r\n\r\n    // const scaleX = newWidth / window.innerWidth;\r\n    // const scaleY = newHeight / window.innerHeight;\r\n    //\r\n    // // Adjust cell width and height based on window size\r\n    // this.width = scaleX * Cell.cellWidth;\r\n    // this.height = scaleY * Cell.cellHeight;\r\n    //\r\n    // // Recalculate position (if necessary) based on the window size\r\n    // this.position.x *= scaleX;\r\n    // this.position.y *= scaleY;\r\n  }\r\n}\r\n\r\n","export const Direction = {\r\n  Up: 0,\r\n  Down: 1,\r\n  Left: 2,\r\n  Right: 3,\r\n};","import {Cell} from './cell';\r\n\r\nconst canvas = document.querySelector('canvas');\r\nconst context = canvas.getContext('2d');\r\n\r\nexport class Player {\r\n  constructor({position}) {\r\n    this.position = position;\r\n    this.width = Cell.cellWidth;\r\n    this.height = Cell.cellHeight;\r\n    this.moved = false;\r\n  }\r\n\r\n  draw() {\r\n    context.lineWidth = 3;\r\n    context.strokeStyle = 'red';\r\n    // position is a coordinate, multiply by the cell size, -1 in width and height to center with the grid\r\n    context.strokeRect(\r\n        this.position.x * Cell.cellWidth - 1,\r\n        this.position.y * Cell.cellHeight - 1,\r\n        this.width,\r\n        this.height,\r\n    );\r\n  }\r\n\r\n  update() {\r\n    if (this.moved) {\r\n      this.moved = false;\r\n    }\r\n    this.draw();\r\n  }\r\n}","import {randomIntFromInterval} from './helper';\r\nimport {Player} from './player';\r\nimport {Cell} from './cell';\r\nimport {Direction} from './eDirection';\r\nimport {images} from './resources';\r\n\r\nconst countdownElement = document.querySelector('#timeElement');\r\nconst distanceElement = document.querySelector('#distanceElement');\r\nconst scoreElement = document.querySelector('#scoreElement');\r\n\r\nconst gameGridRows = 7;\r\nconst gameGridColumns = 9;\r\n// Offset of the next pipe queue\r\nconst uiCoordsOffsetX = 2;\r\n\r\nexport class GameManager {\r\n  constructor() {\r\n\r\n    this.countdownTimer = 20;\r\n    this.currentPipe = {\r\n      x: 0,\r\n      y: 0,\r\n      direction: Direction.Up,\r\n    };\r\n    this.gameGrid = [];\r\n    this.gameStarted = false;\r\n    this.grid = [\r\n      [13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    ];\r\n    this.loadingNextLevel = false;\r\n    this.player = new Player({\r\n      //  position is a coordinate in the grid\r\n      position: {\r\n        x: 5,\r\n        y: 5,\r\n      }\r\n    });\r\n    this.nextPipes = [];\r\n    this.remainingDistance = randomIntFromInterval(4, 20);\r\n    this.score = 0;\r\n    this.stopCountDown = false;\r\n    this.updateQueue = false;\r\n    this.isGameOver = false;\r\n  }\r\n\r\n  addPipe() {\r\n    let nextPipeId = randomIntFromInterval(1, 7);\r\n    this.nextPipes.push(nextPipeId);\r\n    console.log('Number of pipes', this.nextPipes.length);\r\n    this.updateQueue = true;\r\n  }\r\n\r\n  canReceiveWater(type, direction) {\r\n    console.log('Direction', direction, ' Type', type);\r\n    switch (type) {\r\n      case 1: // 4 side pipe\r\n        switch (direction) {\r\n          case Direction.Down:\r\n            this.currentPipe.direction = Direction.Down;\r\n            return true;\r\n          case Direction.Up:\r\n            this.currentPipe.direction = Direction.Up;\r\n            return true;\r\n          case Direction.Left:\r\n            this.currentPipe.direction = Direction.Left;\r\n            return true;\r\n          case Direction.Right:\r\n            this.currentPipe.direction = Direction.Right;\r\n            return true;\r\n        }\r\n        break;\r\n      case 2: // bottom left curve\r\n        switch (direction) {\r\n          case Direction.Up:\r\n          case Direction.Right:\r\n            return false;\r\n          case Direction.Down:\r\n            this.currentPipe.direction = Direction.Right;\r\n            return true;\r\n          case Direction.Left:\r\n            this.currentPipe.direction = Direction.Up;\r\n            return true;\r\n        }\r\n        break;\r\n      case 3: // bottom right curve\r\n        switch (direction) {\r\n          case Direction.Up:\r\n          case Direction.Left:\r\n            return false;\r\n          case Direction.Down:\r\n            this.currentPipe.direction = Direction.Left;\r\n            return true;\r\n          case Direction.Right:\r\n            this.currentPipe.direction = Direction.Up;\r\n            return true;\r\n        }\r\n        break;\r\n      case 4: // top left curve\r\n        switch (direction) {\r\n          case Direction.Up:\r\n            this.currentPipe.direction = Direction.Right;\r\n            return true;\r\n          case Direction.Left:\r\n            this.currentPipe.direction = Direction.Down;\r\n            return true;\r\n          case Direction.Down:\r\n          case Direction.Right:\r\n            return false;\r\n        }\r\n        break;\r\n      case 5: // top right curve\r\n        switch (direction) {\r\n          case Direction.Up:\r\n            this.currentPipe.direction = Direction.Left;\r\n            return true;\r\n          case Direction.Right:\r\n            this.currentPipe.direction = Direction.Down;\r\n            return true;\r\n          case Direction.Down:\r\n          case Direction.Left:\r\n            return false;\r\n        }\r\n        break;\r\n      case 6: // horizontal\r\n        switch (direction) {\r\n          case Direction.Down:\r\n          case Direction.Up:\r\n            return false;\r\n          case Direction.Left:\r\n            this.currentPipe.direction = Direction.Left;\r\n            return true;\r\n          case Direction.Right:\r\n            this.currentPipe.direction = Direction.Right;\r\n            return true;\r\n        }\r\n        break;\r\n      case 7: // vertical\r\n        switch (direction) {\r\n          case Direction.Down:\r\n            this.currentPipe.direction = Direction.Down;\r\n            return true;\r\n          case Direction.Up:\r\n            this.currentPipe.direction = Direction.Up;\r\n            return true;\r\n          case Direction.Left:\r\n          case Direction.Right:\r\n            return false;\r\n        }\r\n        break;\r\n        // Blocked Pipe and starting positions cannot receive water\r\n      case 8:\r\n        console.log('Clogged Pipe');\r\n        return false;\r\n      case 9:\r\n      case 10:\r\n      case 11:\r\n      case 12:\r\n        console.log('Starting Pipe');\r\n        return false;\r\n      default:\r\n        console.log('There is no pipe on this cell');\r\n        return false;\r\n    }\r\n  }\r\n\r\n  drawPipeQueue() {\r\n    console.log('New Pipe in queue drawn');\r\n    this.gameGrid[11] = new Cell({\r\n      position: {\r\n        x: 0,\r\n        y: Cell.cellHeight,\r\n      },\r\n      src: images[this.nextPipes[3]],\r\n      type: this.nextPipes[3],\r\n      gameManager: this,\r\n    });\r\n    this.gameGrid[22] = new Cell({\r\n      position: {\r\n        x: 0,\r\n        y: Cell.cellHeight * 2,\r\n      },\r\n      src: images[this.nextPipes[2]],\r\n      type: this.nextPipes[2],\r\n      gameManager: this,\r\n    });\r\n    this.gameGrid[33] = new Cell({\r\n      position: {\r\n        x: 0,\r\n        y: Cell.cellHeight * 3,\r\n      },\r\n      src: images[this.nextPipes[1]],\r\n      type: this.nextPipes[1],\r\n      gameManager: this,\r\n    });\r\n    this.gameGrid[44] = new Cell({\r\n      position: {\r\n        x: 0,\r\n        y: Cell.cellHeight * 4,\r\n      },\r\n      src: images[this.nextPipes[0]],\r\n      type: this.nextPipes[0],\r\n      gameManager: this,\r\n    });\r\n    this.updateQueue = false;\r\n  }\r\n\r\n  gameOver() {\r\n    scoreElement.innerHTML = '';\r\n    distanceElement.innerHTML = '';\r\n    countdownElement.innerHTML = 'GAME OVER! Press Anywhere to restart the game!';\r\n  }\r\n\r\n  getNextPipeInStream() {\r\n    console.log('trying to fill next pipe');\r\n    // get the current pipe type\r\n    let currentPipeGridId = this.currentPipe.y * 11 + this.currentPipe.x;\r\n    const currentPipe = this.gameGrid[currentPipeGridId];\r\n    currentPipe.withWater = true;\r\n    // check for game over condition based on current pipe coords and direction\r\n    switch (this.currentPipe.direction) {\r\n      case Direction.Down:\r\n        if (this.currentPipe.y + 1 >= gameGridRows) {\r\n          this.isGameOver = true;\r\n        }\r\n        break;\r\n      case Direction.Up:\r\n        if (this.currentPipe.y - 1 < 0) {\r\n          this.isGameOver = true;\r\n        }\r\n        break;\r\n      case Direction.Left:\r\n        if (this.currentPipe.x - 1 < uiCoordsOffsetX) {\r\n          this.isGameOver = true;\r\n        }\r\n        break;\r\n      case Direction.Right:\r\n        if (this.currentPipe.x + 1 >= gameGridColumns + uiCoordsOffsetX) {\r\n          this.isGameOver = true;\r\n        }\r\n        break;\r\n    }\r\n    console.log('Check if current pipe is sending water out of the game grid:',\r\n        this.isGameOver);\r\n\r\n    if (this.isGameOver && this.loadingNextLevel === false) {\r\n      console.log('Game over, sent water out of grid');\r\n      this.gameOver();\r\n      return;\r\n    }\r\n\r\n    // get the next pipe type\r\n    let nextPipeType;\r\n    let nextPipeCoords = {\r\n      x: 0,\r\n      y: 0,\r\n    };\r\n\r\n    switch (this.currentPipe.direction) {\r\n      case Direction.Down:\r\n        nextPipeType = this.grid[this.currentPipe.y + 1][this.currentPipe.x];\r\n        nextPipeCoords.x = this.currentPipe.x;\r\n        nextPipeCoords.y = this.currentPipe.y + 1;\r\n        break;\r\n      case Direction.Up:\r\n        nextPipeType = this.grid[this.currentPipe.y - 1][this.currentPipe.x];\r\n        nextPipeCoords.x = this.currentPipe.x;\r\n        nextPipeCoords.y = this.currentPipe.y - 1;\r\n        break;\r\n      case Direction.Left:\r\n        nextPipeType = this.grid[this.currentPipe.y][this.currentPipe.x - 1];\r\n        nextPipeCoords.x = this.currentPipe.x - 1;\r\n        nextPipeCoords.y = this.currentPipe.y;\r\n        break;\r\n      case Direction.Right:\r\n        nextPipeType = this.grid[this.currentPipe.y][this.currentPipe.x + 1];\r\n        nextPipeCoords.x = this.currentPipe.x + 1;\r\n        nextPipeCoords.y = this.currentPipe.y;\r\n        break;\r\n    }\r\n\r\n    console.log('next pipe coords: ', nextPipeCoords.x, nextPipeCoords.y);\r\n\r\n    /*check if water can flow to the next pipe.\r\n     *return value will dictate game over condition, if it's not game over the direction of the next pipe is already\r\n     *set through this function*/\r\n    if (this.canReceiveWater(nextPipeType, this.currentPipe.direction) === false) {\r\n      this.isGameOver = true;\r\n      if (this.loadingNextLevel === false) {\r\n        console.log(\r\n            'Game Over, the next pipe cannot receive water from the previous pipe', this.isGameOver);\r\n        this.gameOver();\r\n      }\r\n      return;\r\n    }\r\n    console.log('Next Pipe was filled with water!!!');\r\n    // advance water to current pipe\r\n    this.currentPipe.x = nextPipeCoords.x;\r\n    this.currentPipe.y = nextPipeCoords.y;\r\n\r\n    // Check score\r\n    this.score += 100;\r\n    this.remainingDistance--;\r\n    scoreElement.innerHTML = `Score: ${this.score}`;\r\n    distanceElement.innerHTML = `Distance: ${this.remainingDistance}`;\r\n\r\n    // Go to next level if the user completes the required distance\r\n    if (this.remainingDistance <= 0 && this.loadingNextLevel === false) {\r\n      this.stopCountDown = true;\r\n      this.nextLevel();\r\n    }\r\n  }\r\n\r\n  nextLevel() {\r\n    console.log('Next Level');\r\n    // go through all the remaining aligned pipes to give score to the user, if it reaches a dead end avoid a game over\r\n    this.loadingNextLevel = true;\r\n    // Get next pipe to score until its \"game over\"\r\n    while (this.isGameOver === false) {\r\n      this.getNextPipeInStream();\r\n    }\r\n    // reset \"game over\"\r\n    this.isGameOver = false;\r\n\r\n    // subtract score for every pipe not used in the pipe stream\r\n    this.gameGrid.forEach((currentPipe)=>{\r\n      if(currentPipe.type >= 1 && currentPipe.type <= 7){\r\n        if(currentPipe.withWater === false){\r\n          console.log('Penalized 50 for not using a pipe');\r\n          this.score -= 50;\r\n        }\r\n      }\r\n    })\r\n    // Small Countdown coroutine to give the user some feedback\r\n    scoreElement.innerHTML = '';\r\n    distanceElement.innerHTML = '';\r\n\r\n    const countdownTimer = setInterval(() => {\r\n      console.log('countDown: ', this.countdownTimer);\r\n      // Update the countdown display\r\n      countdownElement.innerHTML = `Going to next level in: ${this.countdownTimer}`;\r\n      if (this.countdownTimer <= 0) {\r\n        // Stop the timer\r\n        clearInterval(countdownTimer);\r\n        this.restartGame(true);\r\n      } else {\r\n        // Decrease the countdown\r\n        this.countdownTimer--;\r\n      }\r\n    }, 1000); // Run every 1 second\r\n\r\n  }\r\n\r\n  restartGame(keepScore) {\r\n    this.countdownTimer = 20;\r\n    this.currentPipe = {\r\n      x: 0,\r\n      y: 0,\r\n      direction: Direction.Up,\r\n    };\r\n    this.gameGrid = [];\r\n    this.gameStarted = false;\r\n    this.grid = [\r\n      [13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n      [13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    ];\r\n    this.loadingNextLevel = false;\r\n    this.player = new Player({\r\n      //  position is a coordinate in the grid\r\n      position: {\r\n        x: 5,\r\n        y: 5,\r\n      },\r\n    });\r\n    this.nextPipes = [];\r\n    this.remainingDistance = randomIntFromInterval(4, 20);\r\n    if (keepScore === false) {\r\n      this.score = 0;\r\n    }\r\n    this.stopCountDown = false;\r\n    this.updateQueue = false;\r\n    this.isGameOver = false;\r\n    this.startGame();\r\n  }\r\n\r\n  setPipePosition(mouseX, mouseY) {\r\n    // get the player coords in the grid\r\n    let newPlayerPositionX = Math.floor(mouseX / Cell.cellWidth);\r\n    let newPlayerPositionY = Math.floor(mouseY / Cell.cellHeight);\r\n    // check if the mouse click was within the gaming area\r\n    if (\r\n        newPlayerPositionX >= uiCoordsOffsetX &&\r\n        newPlayerPositionX < gameGridColumns + uiCoordsOffsetX\r\n    ) {\r\n      if (newPlayerPositionY >= 0 && newPlayerPositionY < gameGridRows) {\r\n        // check if this coord can be played, not a bloc pipe nor starting pipe\r\n        for (let index = 8; index <= 12; index++) {\r\n          if (this.grid[newPlayerPositionY][newPlayerPositionX] === index) {\r\n            console.log(\r\n                'Cannot place pipe in this position, its a blocked pipe or starting pipe',\r\n            );\r\n            return;\r\n          }\r\n        }\r\n\r\n        // set this grid value to be the nextPipe\r\n        this.grid[newPlayerPositionY][newPlayerPositionX] =\r\n            this.nextPipes.shift();\r\n        // generate a new random pipe and add it to the queue\r\n        this.addPipe();\r\n        //  set the gameGrid with the new cell (This should be overriden and not a new instance, cant find a proper way to this in js)\r\n        let pressedCellId =\r\n            newPlayerPositionY * (gameGridColumns + uiCoordsOffsetX) +\r\n            newPlayerPositionX;\r\n\r\n        this.gameGrid[pressedCellId] = new Cell({\r\n          position: {\r\n            x: Cell.cellWidth * newPlayerPositionX,\r\n            y: Cell.cellHeight * newPlayerPositionY,\r\n          },\r\n          src: images[this.grid[newPlayerPositionY][newPlayerPositionX]],\r\n          type: this.grid[newPlayerPositionY][newPlayerPositionX],\r\n          gameManager: this,\r\n        });\r\n\r\n        console.log(\r\n            'Pipe was played on coords:',\r\n            newPlayerPositionY,\r\n            newPlayerPositionX,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  startCountdown() {\r\n    const countdownTimer = setInterval(() => {\r\n      if(this.isGameOver){\r\n        clearInterval(countdownTimer);\r\n        return;\r\n      }\r\n      console.log('countDown: ', this.countdownTimer);\r\n      // Update the countdown display\r\n      countdownElement.innerHTML = `Time Left: ${this.countdownTimer}`;\r\n      if (this.countdownTimer <= 0) {\r\n        // Stop the timer\r\n        clearInterval(countdownTimer);\r\n        // Start the game/water flow\r\n        this.startWaterFlow();\r\n      } else {\r\n        // Decrease the countdown\r\n        this.countdownTimer--;\r\n      }\r\n    }, 1000); // Run every 1 second\r\n  }\r\n\r\n  startGame() {\r\n    scoreElement.innerHTML = `Score: ${this.score}`;\r\n    distanceElement.innerHTML = `Distance: ${this.remainingDistance}`;\r\n    countdownElement.innerHTML = `Time Left: ${this.countdownTimer}`;\r\n    this.stopCountDown = false;\r\n\r\n    // set grid\r\n    console.log('Initialize');\r\n    // set blocked cells - image id - 8 - set a random number of blocks between 1 - 4\r\n    const numberBlockedCells = randomIntFromInterval(0, 4);\r\n    for (let index = 0; index < numberBlockedCells; index++) {\r\n      // -1 since its id 0\r\n      let rowPosition = randomIntFromInterval(0, gameGridRows - 1);\r\n      let columnPosition = randomIntFromInterval(\r\n          uiCoordsOffsetX,\r\n          gameGridColumns + 1,\r\n      );\r\n      this.grid[rowPosition][columnPosition] = 8;\r\n      console.log('blockedCell', rowPosition, columnPosition);\r\n    }\r\n\r\n    // set the starting point - random number between 9 - 12 (starting point image id's)\r\n    let initialPipeType = randomIntFromInterval(9, 12);\r\n    let initialIsSet = false;\r\n    while (initialIsSet === false) {\r\n      // -2 because starting position cannot be initialized in the last row\r\n      let rowPosition = randomIntFromInterval(0, gameGridRows - 2);\r\n      let columnPosition = randomIntFromInterval(2, gameGridColumns + 1);\r\n      // check if the position for the starting pipe does not have a blocked cell bellow\r\n      if (this.grid[rowPosition + 1][columnPosition] !== 8) {\r\n        //if pipe is facing right, x cannot be gameGridColumn - 1\r\n        //if pipe is facing left, x cannot be 0\r\n        //if pipe is facing up, y cannot be 0\r\n        //no blocked cell can be in the direction of the water flow\r\n        let canSetStartingPipe = false;\r\n        switch (initialPipeType) {\r\n          case 9:\r\n            let nextColumnId = columnPosition + 1;\r\n            console.log('next column: ', nextColumnId);\r\n            // water flow direction is not out of map or a blocked cell\r\n            if (nextColumnId < gameGridColumns + uiCoordsOffsetX) {\r\n              if (this.grid[rowPosition][nextColumnId] !== 8) {\r\n\r\n                canSetStartingPipe = true;\r\n              }\r\n            }\r\n            break;\r\n\r\n          case 10:\r\n            let previousColumnId = columnPosition - 1;\r\n            // water flow direction is not out of map or a blocked cell\r\n            if (previousColumnId >= uiCoordsOffsetX) {\r\n              if (this.grid[rowPosition][previousColumnId] !== 8) {\r\n                canSetStartingPipe = true;\r\n              }\r\n            }\r\n            break;\r\n          case 11:\r\n            let bellowRowId = rowPosition + 1;\r\n            // water flow direction is not out of map or a blocked cell\r\n            if (bellowRowId > 0) {\r\n              if (this.grid[bellowRowId][columnPosition] !== 8) {\r\n                canSetStartingPipe = true;\r\n              }\r\n            }\r\n            break;\r\n          case 12:\r\n            let aboveRowId = rowPosition - 1;\r\n            // water flow direction is not out of map or a blocked cell\r\n            if (aboveRowId >= 0) {\r\n              if (this.grid[aboveRowId][columnPosition] !== 8) {\r\n                canSetStartingPipe = true;\r\n              }\r\n            }\r\n            break;\r\n        }\r\n        // set starting pipe if possible\r\n        if (canSetStartingPipe) {\r\n          this.grid[rowPosition][columnPosition] = initialPipeType;\r\n          this.currentPipe.y = rowPosition;\r\n          this.currentPipe.x = columnPosition;\r\n          switch (initialPipeType) {\r\n            case 9:\r\n              this.currentPipe.direction = Direction.Right;\r\n              break;\r\n            case 10:\r\n              this.currentPipe.direction = Direction.Left;\r\n              break;\r\n            case 11:\r\n              this.currentPipe.direction = Direction.Down;\r\n              break;\r\n            case 12:\r\n              this.currentPipe.direction = Direction.Up;\r\n              break;\r\n          }\r\n          console.log(\r\n              'Starting pipe of type: ',\r\n              initialPipeType,\r\n              '. was set on position: ',\r\n              rowPosition,\r\n              columnPosition,\r\n              'with starting direction: ',\r\n              this.currentPipe.direction,\r\n          );\r\n          initialIsSet = true;\r\n        } else {\r\n          console.log(\r\n              'pipe type: ',\r\n              initialPipeType,\r\n              'could not place pipe here:',\r\n              columnPosition,\r\n              rowPosition,\r\n              'water would flow out of the map',\r\n          );\r\n        }\r\n      } else {\r\n        // debug purpose to check if this ever happened\r\n        console.log('Could not set initial pipe here');\r\n      }\r\n    }\r\n    // generate the queue with 4 new blocks - image id's - 1 -7\r\n    for (let index = 0; index < 4; index++) {\r\n      this.addPipe();\r\n    }\r\n\r\n    this.gameStarted = true;\r\n\r\n    // set each cell pipeType /  or empty cell\r\n    this.grid.forEach((row, currentRow) => {\r\n      row.forEach((column, currentColumn) => {\r\n        this.gameGrid.push(\r\n            new Cell({\r\n              position: {\r\n                x: Cell.cellWidth * currentColumn,\r\n                y: Cell.cellHeight * currentRow,\r\n              },\r\n              src: images[column],\r\n              type: column,\r\n              gameManager: this,\r\n            }),\r\n        );\r\n      });\r\n    });\r\n    // start water flow countdown\r\n    this.startCountdown();\r\n  }\r\n\r\n  startWaterFlow() {\r\n    console.log('StartWaterFlow');\r\n\r\n    // set the next pipe to be filled     \r\n    const countdownTimer = setInterval(() => {\r\n      if(this.isGameOver){\r\n        clearInterval(countdownTimer);\r\n        return;\r\n      }\r\n      console.log('water flow countDown: ', this.countdownTimer);\r\n      // Update the countdown display\r\n      countdownElement.innerHTML = `Time Left: ${this.countdownTimer}`;\r\n      if (this.isGameOver || this.stopCountDown) {\r\n        console.log('Game Over, stop water flow timer');\r\n        clearInterval(countdownTimer);\r\n        return;\r\n      }\r\n      if (this.countdownTimer <= 0) {\r\n        // restart the timer\r\n        this.countdownTimer = 3;\r\n        // Start the game/water flow\r\n        this.getNextPipeInStream();\r\n      } else {\r\n        // Decrease the countdown\r\n        this.countdownTimer--;\r\n      }\r\n    }, 1000); // Run every 1 second\r\n  }\r\n\r\n  update() {\r\n    if (this.gameStarted === false) {\r\n      return;\r\n    }\r\n    // Update player position\r\n    this.player.update();\r\n    if (this.gameStarted && this.updateQueue) {\r\n      this.drawPipeQueue();\r\n    }\r\n    // draw the cells\r\n    for (const cell in this.gameGrid) {\r\n      this.gameGrid[cell].draw();\r\n    }\r\n  }\r\n}","import {GameManager} from './game-manager.js'\r\n\r\nconst canvas = document.querySelector('canvas');\r\nconst context = canvas.getContext('2d');\r\n\r\nconst countdownElement = document.querySelector('#timeElement');\r\nconst distanceElement = document.querySelector('#distanceElement');\r\nconst scoreElement = document.querySelector('#scoreElement');\r\n\r\nconst gameGridRows = 7;\r\nconst gameGridColumns = 9;\r\n\r\ncanvas.width = innerWidth;\r\ncanvas.height = innerHeight;\r\n\r\n// UI area offset\r\nconst uiOffsetY = -160;\r\nconst uiOffsetX = -160;\r\n// Offset of the next pipe queue\r\nconst uiCoordsOffsetX = 2;\r\n\r\n// fields\r\nconst gameManager = new GameManager();\r\n\r\n// Game Loop\r\nfunction gameLoop() {\r\n  requestAnimationFrame(gameLoop);\r\n  context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n  // draw player position\r\n  gameManager.update();\r\n}\r\n\r\ngameLoop();\r\nwindow.addEventListener('mousedown', (mouse) => {\r\n  if (gameManager.gameStarted && gameManager.isGameOver === false) {\r\n    gameManager.setPipePosition(mouse.clientX + uiOffsetX, mouse.clientY + uiOffsetY);\r\n    return;\r\n  }\r\n  // Click anywhere on screen to restart the game\r\n    console.log('Started Game on Click!');\r\n    gameManager.restartGame(false);\r\n});\r\nwindow.addEventListener('mousemove', (mouse) => {\r\n  if (gameManager.gameStarted) {\r\n    let newPlayerPositionX = Math.floor((mouse.clientX + uiOffsetX) / Cell.cellWidth);\r\n    let newPlayerPositionY = Math.floor(\r\n        (mouse.clientY + uiOffsetY) / Cell.cellHeight,\r\n    );\r\n    if (\r\n        newPlayerPositionX >= uiCoordsOffsetX &&\r\n        newPlayerPositionX < gameGridColumns + uiCoordsOffsetX\r\n    ) {\r\n      if (newPlayerPositionY >= 0 && newPlayerPositionY < gameGridRows) {\r\n        //console.log(\"Hovering different cell\");\r\n        gameManager.player.position.x = newPlayerPositionX;\r\n        gameManager.player.position.y = newPlayerPositionY;\r\n        gameManager.player.moved = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (gameManager.isGameOver === false && gameManager.gameStarted === false) {\r\n    scoreElement.innerHTML = '';\r\n    distanceElement.innerHTML = '';\r\n    countdownElement.innerHTML = 'Press Anywhere to start the game!';\r\n  }\r\n});\r\nwindow.addEventListener('resize',  () => {\r\n  const newWidth = window.innerWidth;\r\n  const newHeight = window.innerHeight;\r\n\r\n  // Resize all cells\r\n  gameManager.gameGrid.forEach(cell => cell.resize(newWidth, newHeight));\r\n\r\n  // Redraw the updated cells\r\n  context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas\r\n  gameManager.gameGrid.forEach(cell => cell.draw()); // Redraw each resized cell\r\n});"],"names":["randomIntFromInterval","min","max","Math","floor","random","context","document","querySelector","getContext","static","constructor","gameManager","position","src","type","this","width","height","pipeImage","Image","onload","image","pipeWithWaterImage","getPipeWithWaterImage","imageFilled","withWater","alreadyFilled","console","log","currentPipe","direction","draw","imageToDraw","drawImage","x","y","fillStyle","fillRect","resize","newWidth","newHeight","Player","cellWidth","cellHeight","moved","lineWidth","strokeStyle","strokeRect","update","countdownElement","distanceElement","scoreElement","innerWidth","innerHeight","countdownTimer","gameGrid","gameStarted","grid","loadingNextLevel","player","nextPipes","remainingDistance","score","stopCountDown","updateQueue","isGameOver","addPipe","nextPipeId","push","length","canReceiveWater","drawPipeQueue","gameOver","innerHTML","getNextPipeInStream","currentPipeGridId","gameGridColumns","nextPipeType","nextPipeCoords","nextLevel","forEach","setInterval","clearInterval","restartGame","keepScore","startGame","setPipePosition","mouseX","mouseY","newPlayerPositionX","newPlayerPositionY","index","shift","pressedCellId","startCountdown","startWaterFlow","numberBlockedCells","rowPosition","gameGridRows","columnPosition","initialPipeType","initialIsSet","canSetStartingPipe","nextColumnId","previousColumnId","bellowRowId","aboveRowId","row","currentRow","column","currentColumn","cell","gameLoop","requestAnimationFrame","clearRect","window","addEventListener","mouse","clientX","clientY","Cell"],"sourceRoot":""}